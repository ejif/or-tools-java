/* ----------------------------------------------------------------------------
 * This file was automatically generated by SWIG (http://www.swig.org).
 * Version 4.0.1
 *
 * Do not make changes to this file unless you know what you are doing--modify
 * the SWIG interface file instead.
 * ----------------------------------------------------------------------------- */

package com.google.ortools.constraintsolver;

public class main implements mainConstants {
  public static long CpRandomSeed() {
    return mainJNI.CpRandomSeed();
  }

  /**
   *  NOLINT This method returns 0. It is useful when 0 can be cast either as a pointer or as an integer value and thus lead to an ambiguous function call.
   */
  public static long zero() {
    return mainJNI.zero();
  }

  /**
   *  This method returns 1
   */
  public static long One() {
    return mainJNI.One();
  }

  /**
   *  NOLINT Given a "source_assignment", clears the "target_assignment" and adds all IntVars in "target_vars", with the values of the variables set according to the corresponding values of "source_vars" in "source_assignment". source_vars and target_vars must have the same number of elements. The source and target assignments can belong to different Solvers.
   */
  public static void setAssignmentFromAssignment(Assignment target_assignment, IntVar[] target_vars, Assignment source_assignment, IntVar[] source_vars) {
    mainJNI.setAssignmentFromAssignment(Assignment.getCPtr(target_assignment), target_assignment, target_vars, Assignment.getCPtr(source_assignment), source_assignment, source_vars);
  }

  public static boolean areAllBound(IntVar[] vars) {
    return mainJNI.areAllBound(vars);
  }

  public static boolean areAllBooleans(IntVar[] vars) {
    return mainJNI.areAllBooleans(vars);
  }

  /**
   *  Returns true if all variables are assigned to 'value'.
   */
  public static boolean areAllBoundTo(IntVar[] vars, long value) {
    return mainJNI.areAllBoundTo(vars, value);
  }

  public static long maxVarArray(IntVar[] vars) {
    return mainJNI.maxVarArray(vars);
  }

  public static long minVarArray(IntVar[] vars) {
    return mainJNI.minVarArray(vars);
  }

  public static long posIntDivUp(long e, long v) {
    return mainJNI.posIntDivUp(e, v);
  }

  public static long posIntDivDown(long e, long v) {
    return mainJNI.posIntDivDown(e, v);
  }

  public static com.google.ortools.constraintsolver.RoutingModelParameters defaultRoutingModelParameters() {
  byte[] buf = mainJNI.defaultRoutingModelParameters();
  if (buf == null || buf.length == 0) {
    return null;
  }
  try {
    return com.google.ortools.constraintsolver.RoutingModelParameters.parseFrom(buf);
  } catch (com.google.protobuf.InvalidProtocolBufferException e) {
    throw new RuntimeException(
        "Unable to parse com.google.ortools.constraintsolver.RoutingModelParameters protocol message.");
  }
}

  public static com.google.ortools.constraintsolver.RoutingSearchParameters defaultRoutingSearchParameters() {
  byte[] buf = mainJNI.defaultRoutingSearchParameters();
  if (buf == null || buf.length == 0) {
    return null;
  }
  try {
    return com.google.ortools.constraintsolver.RoutingSearchParameters.parseFrom(buf);
  } catch (com.google.protobuf.InvalidProtocolBufferException e) {
    throw new RuntimeException(
        "Unable to parse com.google.ortools.constraintsolver.RoutingSearchParameters protocol message.");
  }
}

  /**
   *  Returns an empty std::string if the routing search parameters are valid, and a non-empty, human readable error description if they're not.
   */
  public static String findErrorInRoutingSearchParameters(com.google.ortools.constraintsolver.RoutingSearchParameters search_parameters) {
    return mainJNI.findErrorInRoutingSearchParameters(search_parameters.toByteArray());
  }

  /**
   *  A decision builder which tries to assign values to variables as close as possible to target values first.
   */
  public static DecisionBuilder makeSetValuesFromTargets(Solver solver, IntVar[] variables, long[] targets) {
    long cPtr = mainJNI.makeSetValuesFromTargets(Solver.getCPtr(solver), solver, variables, targets);
    return (cPtr == 0) ? null : new DecisionBuilder(cPtr, false);
  }

  /**
   *  Attempts to solve the model using the cp-sat solver. As of 5/2019, will solve the TSP corresponding to the model if it has a single vehicle. Therefore the resulting solution might not actually be feasible. Will return false if a solution could not be found.
   */
  public static boolean SolveModelWithSat(RoutingModel model, com.google.ortools.constraintsolver.RoutingSearchParameters search_parameters, Assignment initial_solution, Assignment solution) {
    return mainJNI.SolveModelWithSat(RoutingModel.getCPtr(model), model, search_parameters.toByteArray(), Assignment.getCPtr(initial_solution), initial_solution, Assignment.getCPtr(solution), solution);
  }

}
