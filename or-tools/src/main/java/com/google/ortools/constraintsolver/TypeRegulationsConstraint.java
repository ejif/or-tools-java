/* ----------------------------------------------------------------------------
 * This file was automatically generated by SWIG (http://www.swig.org).
 * Version 4.0.1
 *
 * Do not make changes to this file unless you know what you are doing--modify
 * the SWIG interface file instead.
 * ----------------------------------------------------------------------------- */

package com.google.ortools.constraintsolver;

/**
 *  The following constraint ensures that incompatibilities and requirements between types are respected. It verifies both "hard" and "temporal" incompatibilities. Two nodes with hard incompatible types cannot be served by the same vehicle at all, while with a temporal incompatibility they can't be on the same route at the same time. For example, for three temporally incompatible types T1 T2 and T3, two pickup/delivery pairs p1/d1 and p2/d2 of type T1 and T2 respectively, and a non-pickup/delivery node n of type T3, the configuration p1 --&gt; d1 --&gt; n --&gt; p2 --&gt; d2 is acceptable, whereas any configurations with p1 --&gt; p2 --&gt; d1 --&gt; ..., or p1 --&gt; n --&gt; d1 --&gt; ... is not feasible. It also verifies same-vehicle and temporal type requirements. In the above example, if T1 is a requirement for T2: - For a same-vehicle requirement, p1/d1 must be on the same vehicle as   p2/d2. - For a temporal requirement, p2 must be visited between p1 and d1.
 */
public class TypeRegulationsConstraint extends Constraint {
  private transient long swigCPtr;

  protected TypeRegulationsConstraint(long cPtr, boolean cMemoryOwn) {
    super(mainJNI.TypeRegulationsConstraint_SWIGUpcast(cPtr), cMemoryOwn);
    swigCPtr = cPtr;
  }

  protected static long getCPtr(TypeRegulationsConstraint obj) {
    return (obj == null) ? 0 : obj.swigCPtr;
  }

  @SuppressWarnings("deprecation")
  protected void finalize() {
    delete();
  }

  public synchronized void delete() {
    if (swigCPtr != 0) {
      if (swigCMemOwn) {
        swigCMemOwn = false;
        mainJNI.delete_TypeRegulationsConstraint(swigCPtr);
      }
      swigCPtr = 0;
    }
    super.delete();
  }

  public TypeRegulationsConstraint(RoutingModel model) {
    this(mainJNI.new_TypeRegulationsConstraint(RoutingModel.getCPtr(model), model), true);
  }

  public void post() {
    mainJNI.TypeRegulationsConstraint_post(swigCPtr, this);
  }

  public void initialPropagate() {
    mainJNI.TypeRegulationsConstraint_initialPropagate(swigCPtr, this);
  }

}
