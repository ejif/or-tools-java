/* ----------------------------------------------------------------------------
 * This file was automatically generated by SWIG (http://www.swig.org).
 * Version 4.0.1
 *
 * Do not make changes to this file unless you know what you are doing--modify
 * the SWIG interface file instead.
 * ----------------------------------------------------------------------------- */

package com.google.ortools.constraintsolver;

// Used to wrap IndexEvaluator1
// see https://docs.oracle.com/javase/8/docs/api/java/util/function/LongUnaryOperator.html
import java.util.function.LongUnaryOperator;
// Used to wrap IndexEvaluator2
// see https://docs.oracle.com/javase/8/docs/api/java/util/function/LongBinaryOperator.html
import java.util.function.LongBinaryOperator;

public class Pack extends Constraint {
  private transient long swigCPtr;

  protected Pack(long cPtr, boolean cMemoryOwn) {
    super(mainJNI.Pack_SWIGUpcast(cPtr), cMemoryOwn);
    swigCPtr = cPtr;
  }

  protected static long getCPtr(Pack obj) {
    return (obj == null) ? 0 : obj.swigCPtr;
  }

  @SuppressWarnings("deprecation")
  protected void finalize() {
    delete();
  }

  public synchronized void delete() {
    if (swigCPtr != 0) {
      if (swigCMemOwn) {
        swigCMemOwn = false;
        mainJNI.delete_Pack(swigCPtr);
      }
      swigCPtr = 0;
    }
    super.delete();
  }

  public Pack(Solver s, IntVar[] vars, int number_of_bins) {
    this(mainJNI.new_Pack(Solver.getCPtr(s), s, vars, number_of_bins), true);
  }

  /**
   *  Dimensions are additional constraints than can restrict what is possible with the pack constraint. It can be used to set capacity limits, to count objects per bin, to compute unassigned penalties... This dimension imposes that for all bins b, the weighted sum (weights[i]) of all objects i assigned to 'b' is less or equal 'bounds[b]'.
   */
  public void addWeightedSumLessOrEqualConstantDimension(long[] weights, long[] bounds) {
    mainJNI.Pack_addWeightedSumLessOrEqualConstantDimension__SWIG_0(swigCPtr, this, weights, bounds);
  }

  /**
   *  This dimension imposes that for all bins b, the weighted sum (weights-&gt;Run(i)) of all objects i assigned to 'b' is less or equal to 'bounds[b]'. Ownership of the callback is transferred to the pack constraint.
   */
  public void addWeightedSumLessOrEqualConstantDimension(LongUnaryOperator weights, long[] bounds) {
    mainJNI.Pack_addWeightedSumLessOrEqualConstantDimension__SWIG_1(swigCPtr, this, weights, bounds);
  }

  /**
   *  This dimension imposes that for all bins b, the weighted sum (weights-&gt;Run(i, b) of all objects i assigned to 'b' is less or equal to 'bounds[b]'. Ownership of the callback is transferred to the pack constraint.
   */
  public void addWeightedSumLessOrEqualConstantDimension(LongBinaryOperator weights, long[] bounds) {
    mainJNI.Pack_addWeightedSumLessOrEqualConstantDimension__SWIG_2(swigCPtr, this, weights, bounds);
  }

  /**
   *  This dimension imposes that for all bins b, the weighted sum (weights[i]) of all objects i assigned to 'b' is equal to loads[b].
   */
  public void addWeightedSumEqualVarDimension(long[] weights, IntVar[] loads) {
    mainJNI.Pack_addWeightedSumEqualVarDimension__SWIG_0(swigCPtr, this, weights, loads);
  }

  /**
   *  This dimension imposes that for all bins b, the weighted sum (weights-&gt;Run(i, b)) of all objects i assigned to 'b' is equal to loads[b].
   */
  public void addWeightedSumEqualVarDimension(LongBinaryOperator weights, IntVar[] loads) {
    mainJNI.Pack_addWeightedSumEqualVarDimension__SWIG_1(swigCPtr, this, weights, loads);
  }

  /**
   *  This dimension imposes: forall b in bins,    sum (i in items: usage[i] * is_assigned(i, b)) &lt;= capacity[b] where is_assigned(i, b) is true if and only if item i is assigned to the bin b. This can be used to model shapes of items by linking variables of the same item on parallel dimensions with an allowed assignment constraint.
   */
  public void addSumVariableWeightsLessOrEqualConstantDimension(IntVar[] usage, long[] capacity) {
    mainJNI.Pack_addSumVariableWeightsLessOrEqualConstantDimension(swigCPtr, this, usage, capacity);
  }

  /**
   *  This dimension enforces that cost_var == sum of weights[i] for all objects 'i' assigned to a bin.
   */
  public void addWeightedSumOfAssignedDimension(long[] weights, IntVar cost_var) {
    mainJNI.Pack_addWeightedSumOfAssignedDimension(swigCPtr, this, weights, IntVar.getCPtr(cost_var), cost_var);
  }

  /**
   *  This dimension links 'count_var' to the actual number of bins used in the pack.
   */
  public void addCountUsedBinDimension(IntVar count_var) {
    mainJNI.Pack_addCountUsedBinDimension(swigCPtr, this, IntVar.getCPtr(count_var), count_var);
  }

  /**
   *  This dimension links 'count_var' to the actual number of items assigned to a bin in the pack.
   */
  public void addCountAssignedItemsDimension(IntVar count_var) {
    mainJNI.Pack_addCountAssignedItemsDimension(swigCPtr, this, IntVar.getCPtr(count_var), count_var);
  }

  public void post() {
    mainJNI.Pack_post(swigCPtr, this);
  }

  public void clearAll() {
    mainJNI.Pack_clearAll(swigCPtr, this);
  }

  public void propagateDelayed() {
    mainJNI.Pack_propagateDelayed(swigCPtr, this);
  }

  public void initialPropagate() {
    mainJNI.Pack_initialPropagate(swigCPtr, this);
  }

  public void propagate() {
    mainJNI.Pack_propagate(swigCPtr, this);
  }

  public void oneDomain(int var_index) {
    mainJNI.Pack_oneDomain(swigCPtr, this, var_index);
  }

  public String toString() {
    return mainJNI.Pack_toString(swigCPtr, this);
  }

  public boolean isUndecided(int var_index, int bin_index) {
    return mainJNI.Pack_isUndecided(swigCPtr, this, var_index, bin_index);
  }

  public void setImpossible(int var_index, int bin_index) {
    mainJNI.Pack_setImpossible(swigCPtr, this, var_index, bin_index);
  }

  public void assign(int var_index, int bin_index) {
    mainJNI.Pack_assign(swigCPtr, this, var_index, bin_index);
  }

  public boolean isAssignedStatusKnown(int var_index) {
    return mainJNI.Pack_isAssignedStatusKnown(swigCPtr, this, var_index);
  }

  public boolean isPossible(int var_index, int bin_index) {
    return mainJNI.Pack_isPossible(swigCPtr, this, var_index, bin_index);
  }

  public IntVar assignVar(int var_index, int bin_index) {
    long cPtr = mainJNI.Pack_assignVar(swigCPtr, this, var_index, bin_index);
    return (cPtr == 0) ? null : new IntVar(cPtr, false);
  }

  public void setAssigned(int var_index) {
    mainJNI.Pack_setAssigned(swigCPtr, this, var_index);
  }

  public void setUnassigned(int var_index) {
    mainJNI.Pack_setUnassigned(swigCPtr, this, var_index);
  }

  public void removeAllPossibleFromBin(int bin_index) {
    mainJNI.Pack_removeAllPossibleFromBin(swigCPtr, this, bin_index);
  }

  public void assignAllPossibleToBin(int bin_index) {
    mainJNI.Pack_assignAllPossibleToBin(swigCPtr, this, bin_index);
  }

  public void assignFirstPossibleToBin(int bin_index) {
    mainJNI.Pack_assignFirstPossibleToBin(swigCPtr, this, bin_index);
  }

  public void assignAllRemainingItems() {
    mainJNI.Pack_assignAllRemainingItems(swigCPtr, this);
  }

  public void unassignAllRemainingItems() {
    mainJNI.Pack_unassignAllRemainingItems(swigCPtr, this);
  }

  public void accept(ModelVisitor visitor) {
    mainJNI.Pack_accept(swigCPtr, this, ModelVisitor.getCPtr(visitor), visitor);
  }

}
