/* ----------------------------------------------------------------------------
 * This file was automatically generated by SWIG (http://www.swig.org).
 * Version 4.0.1
 *
 * Do not make changes to this file unless you know what you are doing--modify
 * the SWIG interface file instead.
 * ----------------------------------------------------------------------------- */

package com.google.ortools.constraintsolver;

/**
 *  Local Search Filters are used for fast neighbor pruning. Filtering a move is done in several phases: - in the Relax phase, filters determine which parts of their internals   will be changed by the candidate, and modify intermediary State - in the Accept phase, filters check that the candidate is feasible, - if the Accept phase succeeds, the solver may decide to trigger a   Synchronize phase that makes filters change their internal representation   to the last candidate, - otherwise (Accept fails or the solver does not want to synchronize),   a Revert phase makes filters erase any intermediary State generated by the   Relax and Accept phases. A given filter has phases called with the following pattern: (Relax.Accept.Synchronize | Relax.Accept.Revert | Relax.Revert)*. Filters's Revert() is always called in the reverse order their Accept() was called, to allow late filters to use state done/undone by early filters' Accept()/Revert().
 */
public class LocalSearchFilter extends BaseObject {
  private transient long swigCPtr;

  protected LocalSearchFilter(long cPtr, boolean cMemoryOwn) {
    super(mainJNI.LocalSearchFilter_SWIGUpcast(cPtr), cMemoryOwn);
    swigCPtr = cPtr;
  }

  protected static long getCPtr(LocalSearchFilter obj) {
    return (obj == null) ? 0 : obj.swigCPtr;
  }

  @SuppressWarnings("deprecation")
  protected void finalize() {
    delete();
  }

  public synchronized void delete() {
    if (swigCPtr != 0) {
      if (swigCMemOwn) {
        swigCMemOwn = false;
        mainJNI.delete_LocalSearchFilter(swigCPtr);
      }
      swigCPtr = 0;
    }
    super.delete();
  }

  protected void swigDirectorDisconnect() {
    swigCMemOwn = false;
    delete();
  }

  public void swigReleaseOwnership() {
    swigCMemOwn = false;
    mainJNI.LocalSearchFilter_change_ownership(this, swigCPtr, false);
  }

  public void swigTakeOwnership() {
    swigCMemOwn = true;
    mainJNI.LocalSearchFilter_change_ownership(this, swigCPtr, true);
  }

  /**
   *  Lets the filter know what delta and deltadelta will be passed in the next Accept().
   */
  public void Relax(Assignment delta, Assignment deltadelta) {
    if (getClass() == LocalSearchFilter.class) mainJNI.LocalSearchFilter_Relax(swigCPtr, this, Assignment.getCPtr(delta), delta, Assignment.getCPtr(deltadelta), deltadelta); else mainJNI.LocalSearchFilter_RelaxSwigExplicitLocalSearchFilter(swigCPtr, this, Assignment.getCPtr(delta), delta, Assignment.getCPtr(deltadelta), deltadelta);
  }

  /**
   *  Accepts a "delta" given the assignment with which the filter has been synchronized; the delta holds the variables which have been modified and their new value. If the filter represents a part of the global objective, its contribution must be between objective_min and objective_max. Sample: supposing one wants to maintain a[0,1] + b[0,1] &lt;= 1, for the assignment (a,1), (b,0), the delta (b,1) will be rejected but the delta (a,0) will be accepted. TODO(user): Remove arguments when there are no more need for those.
   */
  public boolean accept(Assignment delta, Assignment deltadelta, long objective_min, long objective_max) {
    return mainJNI.LocalSearchFilter_accept(swigCPtr, this, Assignment.getCPtr(delta), delta, Assignment.getCPtr(deltadelta), deltadelta, objective_min, objective_max);
  }

  public boolean isIncremental() {
    return (getClass() == LocalSearchFilter.class) ? mainJNI.LocalSearchFilter_isIncremental(swigCPtr, this) : mainJNI.LocalSearchFilter_isIncrementalSwigExplicitLocalSearchFilter(swigCPtr, this);
  }

  /**
   *  Synchronizes the filter with the current solution, delta being the difference with the solution passed to the previous call to Synchronize() or IncrementalSynchronize(). 'delta' can be used to incrementally synchronizing the filter with the new solution by only considering the changes in delta.
   */
  public void synchronize(Assignment assignment, Assignment delta) {
    mainJNI.LocalSearchFilter_synchronize(swigCPtr, this, Assignment.getCPtr(assignment), assignment, Assignment.getCPtr(delta), delta);
  }

  /**
   *  Cancels the changes made by the last Relax()/Accept() calls.
   */
  public void Revert() {
    if (getClass() == LocalSearchFilter.class) mainJNI.LocalSearchFilter_Revert(swigCPtr, this); else mainJNI.LocalSearchFilter_RevertSwigExplicitLocalSearchFilter(swigCPtr, this);
  }

  /**
   *  Objective value from last time Synchronize() was called.
   */
  public long getSynchronizedObjectiveValue() {
    return (getClass() == LocalSearchFilter.class) ? mainJNI.LocalSearchFilter_getSynchronizedObjectiveValue(swigCPtr, this) : mainJNI.LocalSearchFilter_getSynchronizedObjectiveValueSwigExplicitLocalSearchFilter(swigCPtr, this);
  }

  /**
   *  Objective value from the last time Accept() was called and returned true.
   */
  public long getAcceptedObjectiveValue() {
    return (getClass() == LocalSearchFilter.class) ? mainJNI.LocalSearchFilter_getAcceptedObjectiveValue(swigCPtr, this) : mainJNI.LocalSearchFilter_getAcceptedObjectiveValueSwigExplicitLocalSearchFilter(swigCPtr, this);
  }

  public LocalSearchFilter() {
    this(mainJNI.new_LocalSearchFilter(), true);
    mainJNI.LocalSearchFilter_director_connect(this, swigCPtr, true, true);
  }

}
