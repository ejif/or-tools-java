/* ----------------------------------------------------------------------------
 * This file was automatically generated by SWIG (http://www.swig.org).
 * Version 4.0.1
 *
 * Do not make changes to this file unless you know what you are doing--modify
 * the SWIG interface file instead.
 * ----------------------------------------------------------------------------- */

package com.google.ortools.constraintsolver;

// Used to wrap RoutingTransitCallback2
// see https://docs.oracle.com/javase/8/docs/api/java/util/function/LongBinaryOperator.html
import java.util.function.LongBinaryOperator;
// Used to wrap RoutingTransitCallback1
// see https://docs.oracle.com/javase/8/docs/api/java/util/function/LongUnaryOperator.html
import java.util.function.LongUnaryOperator;

public class RoutingModel {
  private transient long swigCPtr;
  protected transient boolean swigCMemOwn;

  protected RoutingModel(long cPtr, boolean cMemoryOwn) {
    swigCMemOwn = cMemoryOwn;
    swigCPtr = cPtr;
  }

  protected static long getCPtr(RoutingModel obj) {
    return (obj == null) ? 0 : obj.swigCPtr;
  }

  @SuppressWarnings("deprecation")
  protected void finalize() {
    delete();
  }

  public synchronized void delete() {
    if (swigCPtr != 0) {
      if (swigCMemOwn) {
        swigCMemOwn = false;
        mainJNI.delete_RoutingModel(swigCPtr);
      }
      swigCPtr = 0;
    }
  }

  /**
   *  Constant used to express a hard constraint instead of a soft penalty.
   */
  public static long getKNoPenalty() {
    return mainJNI.RoutingModel_kNoPenalty_get();
  }

  /**
   *  Constant used to express the "no disjunction" index, returned when a node does not appear in any disjunction.
   */
  public static int getKNoDisjunction() {
  return mainJNI.RoutingModel_kNoDisjunction_get();
}

  /**
   *  Constant used to express the "no dimension" index, returned when a dimension name does not correspond to an actual dimension.
   */
  public static int getKNoDimension() {
  return mainJNI.RoutingModel_kNoDimension_get();
}

  /**
   *  Constructor taking an index manager. The version which does not take RoutingModelParameters is equivalent to passing DefaultRoutingModelParameters().
   */
  public RoutingModel(RoutingIndexManager index_manager) {
    this(mainJNI.new_RoutingModel__SWIG_0(RoutingIndexManager.getCPtr(index_manager), index_manager), true);
  }

  public RoutingModel(RoutingIndexManager index_manager, com.google.ortools.constraintsolver.RoutingModelParameters parameters) {
    this(mainJNI.new_RoutingModel__SWIG_1(RoutingIndexManager.getCPtr(index_manager), index_manager, parameters.toByteArray()), true);
  }

  /**
   *  Registers 'callback' and returns its index.
   */
  public int registerUnaryTransitCallback(LongUnaryOperator callback) {
    return mainJNI.RoutingModel_registerUnaryTransitCallback(swigCPtr, this, callback);
  }

  public int RegisterPositiveUnaryTransitCallback(LongUnaryOperator callback) {
    return mainJNI.RoutingModel_RegisterPositiveUnaryTransitCallback(swigCPtr, this, callback);
  }

  public int registerTransitCallback(LongBinaryOperator callback) {
    return mainJNI.RoutingModel_registerTransitCallback(swigCPtr, this, callback);
  }

  public int registerPositiveTransitCallback(LongBinaryOperator callback) {
    return mainJNI.RoutingModel_registerPositiveTransitCallback(swigCPtr, this, callback);
  }

  /**
   *  Model creation Methods to add dimensions to routes; dimensions represent quantities accumulated at nodes along the routes. They represent quantities such as weights or volumes carried along the route, or distance or times. Quantities at a node are represented by "cumul" variables and the increase or decrease of quantities between nodes are represented by "transit" variables. These variables are linked as follows: if j == next(i), cumul(j) = cumul(i) + transit(i) + slack(i) where slack is a positive slack variable (can represent waiting times for a time dimension). Setting the value of fix_start_cumul_to_zero to true will force the "cumul" variable of the start node of all vehicles to be equal to 0. Creates a dimension where the transit variable is constrained to be equal to evaluator(i, next(i)); 'slack_max' is the upper bound of the slack variable and 'capacity' is the upper bound of the cumul variables. 'name' is the name used to reference the dimension; this name is used to get cumul and transit variables from the routing model. Returns false if a dimension with the same name has already been created (and doesn't create the new dimension). Takes ownership of the callback 'evaluator'.
   */
  public boolean addDimension(int evaluator_index, long slack_max, long capacity, boolean fix_start_cumul_to_zero, String name) {
    return mainJNI.RoutingModel_addDimension(swigCPtr, this, evaluator_index, slack_max, capacity, fix_start_cumul_to_zero, name);
  }

  public boolean addDimensionWithVehicleTransits(int[] evaluator_indices, long slack_max, long capacity, boolean fix_start_cumul_to_zero, String name) {
    return mainJNI.RoutingModel_addDimensionWithVehicleTransits(swigCPtr, this, evaluator_indices, slack_max, capacity, fix_start_cumul_to_zero, name);
  }

  public boolean addDimensionWithVehicleCapacity(int evaluator_index, long slack_max, long[] vehicle_capacities, boolean fix_start_cumul_to_zero, String name) {
    return mainJNI.RoutingModel_addDimensionWithVehicleCapacity(swigCPtr, this, evaluator_index, slack_max, vehicle_capacities, fix_start_cumul_to_zero, name);
  }

  public boolean addDimensionWithVehicleTransitAndCapacity(int[] evaluator_indices, long slack_max, long[] vehicle_capacities, boolean fix_start_cumul_to_zero, String name) {
    return mainJNI.RoutingModel_addDimensionWithVehicleTransitAndCapacity(swigCPtr, this, evaluator_indices, slack_max, vehicle_capacities, fix_start_cumul_to_zero, name);
  }

  /**
   *  Creates a dimension where the transit variable is constrained to be equal to 'value'; 'capacity' is the upper bound of the cumul variables. 'name' is the name used to reference the dimension; this name is used to get cumul and transit variables from the routing model. Returns false if a dimension with the same name has already been created (and doesn't create the new dimension).
   */
  public boolean addConstantDimensionWithSlack(long value, long capacity, long slack_max, boolean fix_start_cumul_to_zero, String name) {
    return mainJNI.RoutingModel_addConstantDimensionWithSlack(swigCPtr, this, value, capacity, slack_max, fix_start_cumul_to_zero, name);
  }

  public boolean addConstantDimension(long value, long capacity, boolean fix_start_cumul_to_zero, String name) {
    return mainJNI.RoutingModel_addConstantDimension(swigCPtr, this, value, capacity, fix_start_cumul_to_zero, name);
  }

  /**
   *  Creates a dimension where the transit variable is constrained to be equal to 'values[i]' for node i; 'capacity' is the upper bound of the cumul variables. 'name' is the name used to reference the dimension; this name is used to get cumul and transit variables from the routing model. Returns false if a dimension with the same name has already been created (and doesn't create the new dimension).
   */
  public boolean addVectorDimension(long[] values, long capacity, boolean fix_start_cumul_to_zero, String name) {
    return mainJNI.RoutingModel_addVectorDimension(swigCPtr, this, values, capacity, fix_start_cumul_to_zero, name);
  }

  /**
   *  For every vehicle of the routing model: - if total_slacks[vehicle] is not nullptr, constrains it to be the sum of   slacks on that vehicle, that is,   dimension-&gt;CumulVar(end) - dimension-&gt;CumulVar(start) -   sum_{node in path of vehicle} dimension-&gt;FixedTransitVar(node). - if spans[vehicle] is not nullptr, constrains it to be   dimension-&gt;CumulVar(end) - dimension-&gt;CumulVar(start) This does stronger propagation than a decomposition, and takes breaks into account.
   */
  public Constraint MakePathSpansAndTotalSlacks(RoutingDimension dimension, IntVar[] spans, IntVar[] total_slacks) {
    long cPtr = mainJNI.RoutingModel_MakePathSpansAndTotalSlacks(swigCPtr, this, RoutingDimension.getCPtr(dimension), dimension, spans, total_slacks);
    return (cPtr == 0) ? null : new Constraint(cPtr, false);
  }

  /**
   *  Returns true if a dimension exists for a given dimension name.
   */
  public boolean hasDimension(String dimension_name) {
    return mainJNI.RoutingModel_hasDimension(swigCPtr, this, dimension_name);
  }

  /**
   *  Returns a dimension from its name. Dies if the dimension does not exist.
   */
  public RoutingDimension getDimensionOrDie(String dimension_name) {
    return new RoutingDimension(mainJNI.RoutingModel_getDimensionOrDie(swigCPtr, this, dimension_name), false);
  }

  /**
   *  Returns a dimension from its name. Returns nullptr if the dimension does not exist.
   */
  public RoutingDimension getMutableDimension(String dimension_name) {
    long cPtr = mainJNI.RoutingModel_getMutableDimension(swigCPtr, this, dimension_name);
    return (cPtr == 0) ? null : new RoutingDimension(cPtr, false);
  }

  /**
   *  Set the given dimension as "primary constrained". As of August 2013, this is only used by ArcIsMoreConstrainedThanArc(). "dimension" must be the name of an existing dimension, or be empty, in which case there will not be a primary dimension after this call.
   */
  public void setPrimaryConstrainedDimension(String dimension_name) {
    mainJNI.RoutingModel_setPrimaryConstrainedDimension(swigCPtr, this, dimension_name);
  }

  /**
   *  Get the primary constrained dimension, or an empty string if it is unset.
   */
  public String getPrimaryConstrainedDimension() {
    return mainJNI.RoutingModel_getPrimaryConstrainedDimension(swigCPtr, this);
  }

  /**
   *  Adds a disjunction constraint on the indices: exactly 'max_cardinality' of the indices are active. Start and end indices of any vehicle cannot be part of a disjunction. If a penalty is given, at most 'max_cardinality' of the indices can be active, and if less are active, 'penalty' is payed per inactive index. This is equivalent to adding the constraint:     p + Sum(i)active[i] == max_cardinality where p is an integer variable, and the following cost to the cost function:     p * penalty. 'penalty' must be positive to make the disjunction optional; a negative penalty will force 'max_cardinality' indices of the disjunction to be performed, and therefore p == 0. Note: passing a vector with a single index will model an optional index with a penalty cost if it is not visited.
   */
  public int addDisjunction(long[] indices, long penalty, long max_cardinality) {
  return mainJNI.RoutingModel_addDisjunction__SWIG_0(swigCPtr, this, indices, penalty, max_cardinality);
}

  /**
   *  Adds a disjunction constraint on the indices: exactly 'max_cardinality' of the indices are active. Start and end indices of any vehicle cannot be part of a disjunction. If a penalty is given, at most 'max_cardinality' of the indices can be active, and if less are active, 'penalty' is payed per inactive index. This is equivalent to adding the constraint:     p + Sum(i)active[i] == max_cardinality where p is an integer variable, and the following cost to the cost function:     p * penalty. 'penalty' must be positive to make the disjunction optional; a negative penalty will force 'max_cardinality' indices of the disjunction to be performed, and therefore p == 0. Note: passing a vector with a single index will model an optional index with a penalty cost if it is not visited.
   */
  public int addDisjunction(long[] indices, long penalty) {
  return mainJNI.RoutingModel_addDisjunction__SWIG_1(swigCPtr, this, indices, penalty);
}

  /**
   *  Adds a disjunction constraint on the indices: exactly 'max_cardinality' of the indices are active. Start and end indices of any vehicle cannot be part of a disjunction. If a penalty is given, at most 'max_cardinality' of the indices can be active, and if less are active, 'penalty' is payed per inactive index. This is equivalent to adding the constraint:     p + Sum(i)active[i] == max_cardinality where p is an integer variable, and the following cost to the cost function:     p * penalty. 'penalty' must be positive to make the disjunction optional; a negative penalty will force 'max_cardinality' indices of the disjunction to be performed, and therefore p == 0. Note: passing a vector with a single index will model an optional index with a penalty cost if it is not visited.
   */
  public int addDisjunction(long[] indices) {
  return mainJNI.RoutingModel_addDisjunction__SWIG_2(swigCPtr, this, indices);
}

  /**
   *  Returns the indices of the disjunctions to which an index belongs.
   */
  public int[] getDisjunctionIndices(long index) {
  return mainJNI.RoutingModel_getDisjunctionIndices__SWIG_0(swigCPtr, this, index);
}

  /**
   *  Returns the variable indices of the nodes in the disjunction of index 'index'.
   */
  public long[] getDisjunctionIndices(int index) {
  return mainJNI.RoutingModel_getDisjunctionIndices__SWIG_1(swigCPtr, this, index);
}

  /**
   *  Returns the penalty of the node disjunction of index 'index'.
   */
  public long getDisjunctionPenalty(int index) {
    return mainJNI.RoutingModel_getDisjunctionPenalty(swigCPtr, this, index);
  }

  /**
   *  Returns the maximum number of possible active nodes of the node disjunction of index 'index'.
   */
  public long getDisjunctionMaxCardinality(int index) {
    return mainJNI.RoutingModel_getDisjunctionMaxCardinality(swigCPtr, this, index);
  }

  /**
   *  Returns the number of node disjunctions in the model.
   */
  public int getNumberOfDisjunctions() {
    return mainJNI.RoutingModel_getNumberOfDisjunctions(swigCPtr, this);
  }

  /**
   *  SPECIAL: Makes the solver ignore all the disjunctions whose active variables are all trivially zero (i.e. Max() == 0), by setting their max_cardinality to 0. This can be useful when using the BaseBinaryDisjunctionNeighborhood operators, in the context of arc-based routing.
   */
  public void ignoreDisjunctionsAlreadyForcedToZero() {
    mainJNI.RoutingModel_ignoreDisjunctionsAlreadyForcedToZero(swigCPtr, this);
  }

  /**
   *  Adds a soft contraint to force a set of variable indices to be on the same vehicle. If all nodes are not on the same vehicle, each extra vehicle used adds 'cost' to the cost function.
   */
  public void addSoftSameVehicleConstraint(long[] indices, long cost) {
    mainJNI.RoutingModel_addSoftSameVehicleConstraint(swigCPtr, this, indices, cost);
  }

  /**
   *  Sets the vehicles which can visit a given node. If the node is in a disjunction, this will not prevent it from being unperformed. Specifying an empty vector of vehicles has no effect (all vehicles will be allowed to visit the node).
   */
  public void setAllowedVehiclesForIndex(int[] vehicles, long index) {
    mainJNI.RoutingModel_setAllowedVehiclesForIndex(swigCPtr, this, vehicles, index);
  }

  /**
   *  Returns true if a vehicle is allowed to visit a given node.
   */
  public boolean isVehicleAllowedForIndex(int vehicle, long index) {
    return mainJNI.RoutingModel_isVehicleAllowedForIndex(swigCPtr, this, vehicle, index);
  }

  /**
   *  Notifies that index1 and index2 form a pair of nodes which should belong to the same route. This methods helps the search find better solutions, especially in the local search phase. It should be called each time you have an equality constraint linking the vehicle variables of two node (including for instance pickup and delivery problems):     Solver* const solver = routing.solver();     int64 index1 = manager.NodeToIndex(node1);     int64 index2 = manager.NodeToIndex(node2);     solver-&gt;AddConstraint(solver-&gt;MakeEquality(         routing.VehicleVar(index1),         routing.VehicleVar(index2)));     routing.AddPickupAndDelivery(index1, index2);
   */
  public void addPickupAndDelivery(long pickup, long delivery) {
    mainJNI.RoutingModel_addPickupAndDelivery(swigCPtr, this, pickup, delivery);
  }

  /**
   *  Same as AddPickupAndDelivery but notifying that the performed node from the disjunction of index 'pickup_disjunction' is on the same route as the performed node from the disjunction of index 'delivery_disjunction'.
   */
  public void addPickupAndDeliverySets(int pickup_disjunction, int delivery_disjunction) {
    mainJNI.RoutingModel_addPickupAndDeliverySets(swigCPtr, this, pickup_disjunction, delivery_disjunction);
  }

  /**
   *  Sets the Pickup and delivery policy of all vehicles. It is equivalent to calling SetPickupAndDeliveryPolicyOfVehicle on all vehicles.
   */
  public void setPickupAndDeliveryPolicyOfAllVehicles(int policy) {
    mainJNI.RoutingModel_setPickupAndDeliveryPolicyOfAllVehicles(swigCPtr, this, policy);
  }

  public void setPickupAndDeliveryPolicyOfVehicle(int policy, int vehicle) {
    mainJNI.RoutingModel_setPickupAndDeliveryPolicyOfVehicle(swigCPtr, this, policy, vehicle);
  }

  public int getPickupAndDeliveryPolicyOfVehicle(int vehicle) {
    return mainJNI.RoutingModel_getPickupAndDeliveryPolicyOfVehicle(swigCPtr, this, vehicle);
  }

  /**
   *  Returns the number of non-start/end nodes which do not appear in a pickup/delivery pair.
   */
  public int getNumOfSingletonNodes() {
    return mainJNI.RoutingModel_getNumOfSingletonNodes(swigCPtr, this);
  }

  /**
   *  Set the node visit types and incompatibilities/requirements between the types (see below). NOTE: The visit type of a node must be positive, and all nodes belonging to the same pickup/delivery pair must have the same type (or no type at all). NOTE: Before adding any incompatibilities and/or requirements on types:       1) All corresponding node types must have been set.       2) CloseVisitTypes() must be called so all containers are resized          accordingly. NOTE: These incompatibilities and requirements are only handled when each node index appears in at most one pickup/delivery pair, i.e. when the same node isn't a pickup and/or delivery in multiple pickup/delivery pairs.
   */
  public void setVisitType(long index, int type) {
    mainJNI.RoutingModel_setVisitType(swigCPtr, this, index, type);
  }

  public int getVisitType(long index) {
    return mainJNI.RoutingModel_getVisitType(swigCPtr, this, index);
  }

  public int getNumberOfVisitTypes() {
    return mainJNI.RoutingModel_getNumberOfVisitTypes(swigCPtr, this);
  }

  /**
   *  Get the "unperformed" penalty of a node. This is only well defined if the node is only part of a single Disjunction involving only itself, and that disjunction has a penalty. In all other cases, including forced active nodes, this returns 0.
   */
  public long unperformedPenalty(long var_index) {
    return mainJNI.RoutingModel_unperformedPenalty(swigCPtr, this, var_index);
  }

  /**
   *  Same as above except that it returns default_value instead of 0 when penalty is not well defined (default value is passed as first argument to simplify the usage of the method in a callback).
   */
  public long unperformedPenaltyOrValue(long default_value, long var_index) {
    return mainJNI.RoutingModel_unperformedPenaltyOrValue(swigCPtr, this, default_value, var_index);
  }

  /**
   *  Returns the variable index of the first starting or ending node of all routes. If all routes start  and end at the same node (single depot), this is the node returned.
   */
  public long getDepot() {
    return mainJNI.RoutingModel_getDepot(swigCPtr, this);
  }

  /**
   *  Sets the cost function of the model such that the cost of a segment of a route between node 'from' and 'to' is evaluator(from, to), whatever the route or vehicle performing the route.
   */
  public void setArcCostEvaluatorOfAllVehicles(int evaluator_index) {
    mainJNI.RoutingModel_setArcCostEvaluatorOfAllVehicles(swigCPtr, this, evaluator_index);
  }

  /**
   *  Sets the cost function for a given vehicle route.
   */
  public void setArcCostEvaluatorOfVehicle(int evaluator_index, int vehicle) {
    mainJNI.RoutingModel_setArcCostEvaluatorOfVehicle(swigCPtr, this, evaluator_index, vehicle);
  }

  /**
   *  Sets the fixed cost of all vehicle routes. It is equivalent to calling SetFixedCostOfVehicle on all vehicle routes.
   */
  public void setFixedCostOfAllVehicles(long cost) {
    mainJNI.RoutingModel_setFixedCostOfAllVehicles(swigCPtr, this, cost);
  }

  /**
   *  Sets the fixed cost of one vehicle route.
   */
  public void setFixedCostOfVehicle(long cost, int vehicle) {
    mainJNI.RoutingModel_setFixedCostOfVehicle(swigCPtr, this, cost, vehicle);
  }

  /**
   *  Returns the route fixed cost taken into account if the route of the vehicle is not empty, aka there's at least one node on the route other than the first and last nodes.
   */
  public long getFixedCostOfVehicle(int vehicle) {
    return mainJNI.RoutingModel_getFixedCostOfVehicle(swigCPtr, this, vehicle);
  }

  /**
   *  The following methods set the linear and quadratic cost factors of vehicles (must be positive values). The default value of these parameters is zero for all vehicles. When set, the cost_ of the model will contain terms aiming at reducing the number of vehicles used in the model, by adding the following to the objective for every vehicle v: INDICATOR(v used in the model) *   [linear_cost_factor_of_vehicle_[v]    - quadratic_cost_factor_of_vehicle_[v]*(square of length of route v)] i.e. for every used vehicle, we add the linear factor as fixed cost, and subtract the square of the route length multiplied by the quadratic factor. This second term aims at making the routes as dense as possible. Sets the linear and quadratic cost factor of all vehicles.
   */
  public void setAmortizedCostFactorsOfAllVehicles(long linear_cost_factor, long quadratic_cost_factor) {
    mainJNI.RoutingModel_setAmortizedCostFactorsOfAllVehicles(swigCPtr, this, linear_cost_factor, quadratic_cost_factor);
  }

  /**
   *  Sets the linear and quadratic cost factor of the given vehicle.
   */
  public void setAmortizedCostFactorsOfVehicle(long linear_cost_factor, long quadratic_cost_factor, int vehicle) {
    mainJNI.RoutingModel_setAmortizedCostFactorsOfVehicle(swigCPtr, this, linear_cost_factor, quadratic_cost_factor, vehicle);
  }

  public long[] getAmortizedLinearCostFactorOfVehicles() {
  return mainJNI.RoutingModel_getAmortizedLinearCostFactorOfVehicles(swigCPtr, this);
}

  public long[] getAmortizedQuadraticCostFactorOfVehicles() {
  return mainJNI.RoutingModel_getAmortizedQuadraticCostFactorOfVehicles(swigCPtr, this);
}

  public void ConsiderEmptyRouteCostsForVehicle(boolean consider_costs, int vehicle) {
    mainJNI.RoutingModel_ConsiderEmptyRouteCostsForVehicle(swigCPtr, this, consider_costs, vehicle);
  }

  public boolean AreEmptyRouteCostsConsideredForVehicle(int vehicle) {
    return mainJNI.RoutingModel_AreEmptyRouteCostsConsideredForVehicle(swigCPtr, this, vehicle);
  }

  /**
   *  Gets/sets the evaluator used during the search. Only relevant when RoutingSearchParameters.first_solution_strategy = EVALUATOR_STRATEGY. Takes ownership of evaluator.
   */
  public void setFirstSolutionEvaluator(LongBinaryOperator evaluator) {
    mainJNI.RoutingModel_setFirstSolutionEvaluator(swigCPtr, this, evaluator);
  }

  /**
   *  Adds a local search operator to the set of operators used to solve the vehicle routing problem.
   */
  public void addLocalSearchOperator(LocalSearchOperator ls_operator) {
    mainJNI.RoutingModel_addLocalSearchOperator(swigCPtr, this, LocalSearchOperator.getCPtr(ls_operator), ls_operator);
  }

  /**
   *  Adds a search monitor to the search used to solve the routing model.
   */
  public void addSearchMonitor(SearchMonitor monitor) {
    mainJNI.RoutingModel_addSearchMonitor(swigCPtr, this, SearchMonitor.getCPtr(monitor), monitor);
  }

  /**
   *  Adds a callback called each time a solution is found during the search. This is a shortcut to creating a monitor to call the callback on AtSolution() and adding it with AddSearchMonitor.
   */
  public void addAtSolutionCallback(Runnable callback) {
    mainJNI.RoutingModel_addAtSolutionCallback(swigCPtr, this, callback);
  }

  /**
   *  Adds a variable to minimize in the solution finalizer. The solution finalizer is called each time a solution is found during the search and allows to instantiate secondary variables (such as dimension cumul variables).
   */
  public void addVariableMinimizedByFinalizer(IntVar var) {
    mainJNI.RoutingModel_addVariableMinimizedByFinalizer(swigCPtr, this, IntVar.getCPtr(var), var);
  }

  /**
   *  Adds a variable to maximize in the solution finalizer (see above for information on the solution finalizer).
   */
  public void addVariableMaximizedByFinalizer(IntVar var) {
    mainJNI.RoutingModel_addVariableMaximizedByFinalizer(swigCPtr, this, IntVar.getCPtr(var), var);
  }

  /**
   *  Adds a variable to minimize in the solution finalizer, with a weighted priority: the higher the more priority it has.
   */
  public void AddWeightedVariableMinimizedByFinalizer(IntVar var, long cost) {
    mainJNI.RoutingModel_AddWeightedVariableMinimizedByFinalizer(swigCPtr, this, IntVar.getCPtr(var), var, cost);
  }

  /**
   *  Add a variable to set the closest possible to the target value in the solution finalizer.
   */
  public void AddVariableTargetToFinalizer(IntVar var, long target) {
    mainJNI.RoutingModel_AddVariableTargetToFinalizer(swigCPtr, this, IntVar.getCPtr(var), var, target);
  }

  /**
   *  Closes the current routing model; after this method is called, no modification to the model can be done, but RoutesToAssignment becomes available. Note that CloseModel() is automatically called by Solve() and other methods that produce solution. This is equivalent to calling CloseModelWithParameters(DefaultRoutingSearchParameters()).
   */
  public void closeModel() {
    mainJNI.RoutingModel_closeModel(swigCPtr, this);
  }

  /**
   *  Same as above taking search parameters (as of 10/2015 some the parameters have to be set when closing the model).
   */
  public void closeModelWithParameters(com.google.ortools.constraintsolver.RoutingSearchParameters search_parameters) {
    mainJNI.RoutingModel_closeModelWithParameters(swigCPtr, this, search_parameters.toByteArray());
  }

  /**
   *  Solves the current routing model; closes the current model. This is equivalent to calling SolveWithParameters(DefaultRoutingSearchParameters()) or SolveFromAssignmentWithParameters(assignment,                                   DefaultRoutingSearchParameters()).
   */
  public Assignment solve(Assignment assignment) {
    long cPtr = mainJNI.RoutingModel_solve__SWIG_0(swigCPtr, this, Assignment.getCPtr(assignment), assignment);
    return (cPtr == 0) ? null : new Assignment(cPtr, false);
  }

  /**
   *  Solves the current routing model; closes the current model. This is equivalent to calling SolveWithParameters(DefaultRoutingSearchParameters()) or SolveFromAssignmentWithParameters(assignment,                                   DefaultRoutingSearchParameters()).
   */
  public Assignment solve() {
    long cPtr = mainJNI.RoutingModel_solve__SWIG_1(swigCPtr, this);
    return (cPtr == 0) ? null : new Assignment(cPtr, false);
  }

  /**
   *  Solves the current routing model with the given parameters. If 'solutions' is specified, it will contain the k best solutions found during the search (from worst to best, including the one returned by this method), where k corresponds to the 'number_of_solutions_to_collect' in 'search_parameters'. Note that the Assignment returned by the method and the ones in solutions are owned by the underlying solver and should not be deleted.
   */
  public Assignment solveWithParameters(com.google.ortools.constraintsolver.RoutingSearchParameters search_parameters) {
    long cPtr = mainJNI.RoutingModel_solveWithParameters(swigCPtr, this, search_parameters.toByteArray());
    return (cPtr == 0) ? null : new Assignment(cPtr, false);
  }

  public Assignment solveFromAssignmentWithParameters(Assignment assignment, com.google.ortools.constraintsolver.RoutingSearchParameters search_parameters) {
    long cPtr = mainJNI.RoutingModel_solveFromAssignmentWithParameters(swigCPtr, this, Assignment.getCPtr(assignment), assignment, search_parameters.toByteArray());
    return (cPtr == 0) ? null : new Assignment(cPtr, false);
  }

  /**
   *  Given a "source_model" and its "source_assignment", resets "target_assignment" with the IntVar variables (nexts_, and vehicle_vars_ if costs aren't homogeneous across vehicles) of "this" model, with the values set according to those in "other_assignment". The objective_element of target_assignment is set to this-&gt;cost_.
   */
  public void setAssignmentFromOtherModelAssignment(Assignment target_assignment, RoutingModel source_model, Assignment source_assignment) {
    mainJNI.RoutingModel_setAssignmentFromOtherModelAssignment(swigCPtr, this, Assignment.getCPtr(target_assignment), target_assignment, RoutingModel.getCPtr(source_model), source_model, Assignment.getCPtr(source_assignment), source_assignment);
  }

  /**
   *  Computes a lower bound to the routing problem solving a linear assignment problem. The routing model must be closed before calling this method. Note that problems with node disjunction constraints (including optional nodes) and non-homogenous costs are not supported (the method returns 0 in these cases).
   */
  public long computeLowerBound() {
    return mainJNI.RoutingModel_computeLowerBound(swigCPtr, this);
  }

  /**
   *  Returns the current status of the routing model.
   */
  public int status() {
    return mainJNI.RoutingModel_status(swigCPtr, this);
  }

  /**
   *  Applies a lock chain to the next search. 'locks' represents an ordered vector of nodes representing a partial route which will be fixed during the next search; it will constrain next variables such that: next[locks[i]] == locks[i+1]. Returns the next variable at the end of the locked chain; this variable is not locked. An assignment containing the locks can be obtained by calling PreAssignment().
   */
  public IntVar applyLocks(long[] locks) {
    long cPtr = mainJNI.RoutingModel_applyLocks(swigCPtr, this, locks);
    return (cPtr == 0) ? null : new IntVar(cPtr, false);
  }

  /**
   *  Applies lock chains to all vehicles to the next search, such that locks[p] is the lock chain for route p. Returns false if the locks do not contain valid routes; expects that the routes do not contain the depots, i.e. there are empty vectors in place of empty routes. If close_routes is set to true, adds the end nodes to the route of each vehicle and deactivates other nodes. An assignment containing the locks can be obtained by calling PreAssignment().
   */
  public boolean applyLocksToAllVehicles(long[][] locks, boolean close_routes) {
    return mainJNI.RoutingModel_applyLocksToAllVehicles(swigCPtr, this, locks, close_routes);
  }

  /**
   *  Returns an assignment used to fix some of the variables of the problem. In practice, this assignment locks partial routes of the problem. This can be used in the context of locking the parts of the routes which have already been driven in online routing problems.
   */
  public Assignment preAssignment() {
    long cPtr = mainJNI.RoutingModel_preAssignment(swigCPtr, this);
    return (cPtr == 0) ? null : new Assignment(cPtr, false);
  }

  public Assignment mutablePreAssignment() {
    long cPtr = mainJNI.RoutingModel_mutablePreAssignment(swigCPtr, this);
    return (cPtr == 0) ? null : new Assignment(cPtr, false);
  }

  /**
   *  Writes the current solution to a file containing an AssignmentProto. Returns false if the file cannot be opened or if there is no current solution.
   */
  public boolean writeAssignment(String file_name) {
    return mainJNI.RoutingModel_writeAssignment(swigCPtr, this, file_name);
  }

  /**
   *  Reads an assignment from a file and returns the current solution. Returns nullptr if the file cannot be opened or if the assignment is not valid.
   */
  public Assignment readAssignment(String file_name) {
    long cPtr = mainJNI.RoutingModel_readAssignment(swigCPtr, this, file_name);
    return (cPtr == 0) ? null : new Assignment(cPtr, false);
  }

  /**
   *  Restores an assignment as a solution in the routing model and returns the new solution. Returns nullptr if the assignment is not valid.
   */
  public Assignment restoreAssignment(Assignment solution) {
    long cPtr = mainJNI.RoutingModel_restoreAssignment(swigCPtr, this, Assignment.getCPtr(solution), solution);
    return (cPtr == 0) ? null : new Assignment(cPtr, false);
  }

  /**
   *  Restores the routes as the current solution. Returns nullptr if the solution cannot be restored (routes do not contain a valid solution). Note that calling this method will run the solver to assign values to the dimension variables; this may take considerable amount of time, especially when using dimensions with slack.
   */
  public Assignment readAssignmentFromRoutes(long[][] routes, boolean ignore_inactive_indices) {
    long cPtr = mainJNI.RoutingModel_readAssignmentFromRoutes(swigCPtr, this, routes, ignore_inactive_indices);
    return (cPtr == 0) ? null : new Assignment(cPtr, false);
  }

  /**
   *  Fills an assignment from a specification of the routes of the vehicles. The routes are specified as lists of variable indices that appear on the routes of the vehicles. The indices of the outer vector in 'routes' correspond to vehicles IDs, the inner vector contains the variable indices on the routes for the given vehicle. The inner vectors must not contain the start and end indices, as these are determined by the routing model.  Sets the value of NextVars in the assignment, adding the variables to the assignment if necessary. The method does not touch other variables in the assignment. The method can only be called after the model is closed.  With ignore_inactive_indices set to false, this method will fail (return nullptr) in case some of the route contain indices that are deactivated in the model; when set to true, these indices will be skipped.  Returns true if routes were successfully loaded. However, such assignment still might not be a valid solution to the routing problem due to more complex constraints; it is advisible to call solver()-&gt;CheckSolution() afterwards.
   */
  public boolean routesToAssignment(long[][] routes, boolean ignore_inactive_indices, boolean close_routes, Assignment assignment) {
    return mainJNI.RoutingModel_routesToAssignment(swigCPtr, this, routes, ignore_inactive_indices, close_routes, Assignment.getCPtr(assignment), assignment);
  }

  /**
   *  Converts the solution in the given assignment to routes for all vehicles. Expects that assignment contains a valid solution (i.e. routes for all vehicles end with an end index for that vehicle).
   */
  public void assignmentToRoutes(Assignment assignment, long[][] routes) {
    mainJNI.RoutingModel_assignmentToRoutes(swigCPtr, this, Assignment.getCPtr(assignment), assignment, routes);
  }

  /**
   *  Returns a compacted version of the given assignment, in which all vehicles with id lower or equal to some N have non-empty routes, and all vehicles with id greater than N have empty routes. Does not take ownership of the returned object. If found, the cost of the compact assignment is the same as in the original assignment and it preserves the values of 'active' variables. Returns nullptr if a compact assignment was not found. This method only works in homogenous mode, and it only swaps equivalent vehicles (vehicles with the same start and end nodes). When creating the compact assignment, the empty plan is replaced by the route assigned to the compatible vehicle with the highest id. Note that with more complex constraints on vehicle variables, this method might fail even if a compact solution exists. This method changes the vehicle and dimension variables as necessary. While compacting the solution, only basic checks on vehicle variables are performed; if one of these checks fails no attempts to repair it are made (instead, the method returns nullptr).
   */
  public Assignment compactAssignment(Assignment assignment) {
    long cPtr = mainJNI.RoutingModel_compactAssignment(swigCPtr, this, Assignment.getCPtr(assignment), assignment);
    return (cPtr == 0) ? null : new Assignment(cPtr, false);
  }

  /**
   *  Same as CompactAssignment() but also checks the validity of the final compact solution; if it is not valid, no attempts to repair it are made (instead, the method returns nullptr).
   */
  public Assignment compactAndCheckAssignment(Assignment assignment) {
    long cPtr = mainJNI.RoutingModel_compactAndCheckAssignment(swigCPtr, this, Assignment.getCPtr(assignment), assignment);
    return (cPtr == 0) ? null : new Assignment(cPtr, false);
  }

  /**
   *  Adds an extra variable to the vehicle routing assignment.
   */
  public void addToAssignment(IntVar var) {
    mainJNI.RoutingModel_addToAssignment(swigCPtr, this, IntVar.getCPtr(var), var);
  }

  public void addIntervalToAssignment(IntervalVar interval) {
    mainJNI.RoutingModel_addIntervalToAssignment(swigCPtr, this, IntervalVar.getCPtr(interval), interval);
  }

  /**
   *  Adds a custom local search filter to the list of filters used to speed up local search by pruning unfeasible variable assignments. Calling this method after the routing model has been closed (CloseModel() or Solve() has been called) has no effect. The routing model does not take ownership of the filter.
   */
  public void addLocalSearchFilter(LocalSearchFilter filter) {
    mainJNI.RoutingModel_addLocalSearchFilter(swigCPtr, this, LocalSearchFilter.getCPtr(filter), filter);
  }

  /**
   *  Model inspection. Returns the variable index of the starting node of a vehicle route.
   */
  public long start(int vehicle) {
    return mainJNI.RoutingModel_start(swigCPtr, this, vehicle);
  }

  /**
   *  Returns the variable index of the ending node of a vehicle route.
   */
  public long end(int vehicle) {
    return mainJNI.RoutingModel_end(swigCPtr, this, vehicle);
  }

  /**
   *  Returns true if 'index' represents the first node of a route.
   */
  public boolean isStart(long index) {
    return mainJNI.RoutingModel_isStart(swigCPtr, this, index);
  }

  /**
   *  Returns true if 'index' represents the last node of a route.
   */
  public boolean isEnd(long index) {
    return mainJNI.RoutingModel_isEnd(swigCPtr, this, index);
  }

  /**
   *  Returns the vehicle of the given start/end index, and -1 if the given index is not a vehicle start/end.
   */
  public int VehicleIndex(int index) {
    return mainJNI.RoutingModel_VehicleIndex(swigCPtr, this, index);
  }

  /**
   *  Assignment inspection Returns the variable index of the node directly after the node corresponding to 'index' in 'assignment'.
   */
  public long next(Assignment assignment, long index) {
    return mainJNI.RoutingModel_next(swigCPtr, this, Assignment.getCPtr(assignment), assignment, index);
  }

  /**
   *  Returns true if the route of 'vehicle' is non empty in 'assignment'.
   */
  public boolean isVehicleUsed(Assignment assignment, int vehicle) {
    return mainJNI.RoutingModel_isVehicleUsed(swigCPtr, this, Assignment.getCPtr(assignment), assignment, vehicle);
  }

  /**
   *  Returns all next variables of the model, such that Nexts(i) is the next variable of the node corresponding to i.
   */
  public IntVar[] nexts() {
  return mainJNI.RoutingModel_nexts(swigCPtr, this);
}

  /**
   *  Returns all vehicle variables of the model,  such that VehicleVars(i) is the vehicle variable of the node corresponding to i.
   */
  public IntVar[] vehicleVars() {
  return mainJNI.RoutingModel_vehicleVars(swigCPtr, this);
}

  /**
   *  Returns the next variable of the node corresponding to index. Note that NextVar(index) == index is equivalent to ActiveVar(index) == 0.
   */
  public IntVar nextVar(long index) {
    long cPtr = mainJNI.RoutingModel_nextVar(swigCPtr, this, index);
    return (cPtr == 0) ? null : new IntVar(cPtr, false);
  }

  /**
   *  Returns the active variable of the node corresponding to index.
   */
  public IntVar activeVar(long index) {
    long cPtr = mainJNI.RoutingModel_activeVar(swigCPtr, this, index);
    return (cPtr == 0) ? null : new IntVar(cPtr, false);
  }

  /**
   *  Returns the variable specifying whether or not costs are considered for vehicle.
   */
  public IntVar VehicleCostsConsideredVar(int vehicle) {
    long cPtr = mainJNI.RoutingModel_VehicleCostsConsideredVar(swigCPtr, this, vehicle);
    return (cPtr == 0) ? null : new IntVar(cPtr, false);
  }

  /**
   *  Returns the vehicle variable of the node corresponding to index. Note that VehicleVar(index) == -1 is equivalent to ActiveVar(index) == 0.
   */
  public IntVar vehicleVar(long index) {
    long cPtr = mainJNI.RoutingModel_vehicleVar(swigCPtr, this, index);
    return (cPtr == 0) ? null : new IntVar(cPtr, false);
  }

  /**
   *  Returns the global cost variable which is being minimized.
   */
  public IntVar costVar() {
    long cPtr = mainJNI.RoutingModel_costVar(swigCPtr, this);
    return (cPtr == 0) ? null : new IntVar(cPtr, false);
  }

  /**
   *  Returns the cost of the transit arc between two nodes for a given vehicle. Input are variable indices of node. This returns 0 if vehicle &lt; 0.
   */
  public long getArcCostForVehicle(long from_index, long to_index, long vehicle) {
    return mainJNI.RoutingModel_getArcCostForVehicle(swigCPtr, this, from_index, to_index, vehicle);
  }

  /**
   *  Whether costs are homogeneous across all vehicles.
   */
  public boolean costsAreHomogeneousAcrossVehicles() {
    return mainJNI.RoutingModel_costsAreHomogeneousAcrossVehicles(swigCPtr, this);
  }

  /**
   *  Returns the cost of the segment between two nodes supposing all vehicle costs are the same (returns the cost for the first vehicle otherwise).
   */
  public long getHomogeneousCost(long from_index, long to_index) {
    return mainJNI.RoutingModel_getHomogeneousCost(swigCPtr, this, from_index, to_index);
  }

  /**
   *  Returns the cost of the arc in the context of the first solution strategy. This is typically a simplification of the actual cost; see the .cc.
   */
  public long getArcCostForFirstSolution(long from_index, long to_index) {
    return mainJNI.RoutingModel_getArcCostForFirstSolution(swigCPtr, this, from_index, to_index);
  }

  /**
   *  Returns the cost of the segment between two nodes for a given cost class. Input are variable indices of nodes and the cost class. Unlike GetArcCostForVehicle(), if cost_class is kNoCost, then the returned cost won't necessarily be zero: only some of the components of the cost that depend on the cost class will be omited. See the code for details.
   */
  public long getArcCostForClass(long from_index, long to_index, long cost_class_index) {
    return mainJNI.RoutingModel_getArcCostForClass(swigCPtr, this, from_index, to_index, cost_class_index);
  }

  /**
   *  Get the cost class index of the given vehicle.
   */
  public int getCostClassIndexOfVehicle(long vehicle) {
  return mainJNI.RoutingModel_getCostClassIndexOfVehicle(swigCPtr, this, vehicle);
}

  /**
   *  Returns true iff the model contains a vehicle with the given cost_class_index.
   */
  public boolean hasVehicleWithCostClassIndex(int cost_class_index) {
    return mainJNI.RoutingModel_hasVehicleWithCostClassIndex(swigCPtr, this, cost_class_index);
  }

  /**
   *  Returns the number of different cost classes in the model.
   */
  public int getCostClassesCount() {
    return mainJNI.RoutingModel_getCostClassesCount(swigCPtr, this);
  }

  /**
   *  Ditto, minus the 'always zero', built-in cost class.
   */
  public int getNonZeroCostClassesCount() {
    return mainJNI.RoutingModel_getNonZeroCostClassesCount(swigCPtr, this);
  }

  public int getVehicleClassIndexOfVehicle(long vehicle) {
  return mainJNI.RoutingModel_getVehicleClassIndexOfVehicle(swigCPtr, this, vehicle);
}

  /**
   *  Returns the number of different vehicle classes in the model.
   */
  public int getVehicleClassesCount() {
    return mainJNI.RoutingModel_getVehicleClassesCount(swigCPtr, this);
  }

  /**
   *  Returns variable indices of nodes constrained to be on the same route.
   */
  public int[] getSameVehicleIndicesOfIndex(int node) {
  return mainJNI.RoutingModel_getSameVehicleIndicesOfIndex(swigCPtr, this, node);
}

  /**
   *  Returns whether the arc from-&gt;to1 is more constrained than from-&gt;to2, taking into account, in order: - whether the destination node isn't an end node - whether the destination node is mandatory - whether the destination node is bound to the same vehicle as the source - the "primary constrained" dimension (see SetPrimaryConstrainedDimension) It then breaks ties using, in order: - the arc cost (taking unperformed penalties into account) - the size of the vehicle vars of "to1" and "to2" (lowest size wins) - the value: the lowest value of the indices to1 and to2 wins. See the .cc for details. The more constrained arc is typically preferable when building a first solution. This method is intended to be used as a callback for the BestValueByComparisonSelector value selector. Args:   from: the variable index of the source node   to1: the variable index of the first candidate destination node.   to2: the variable index of the second candidate destination node.
   */
  public boolean arcIsMoreConstrainedThanArc(long from, long to1, long to2) {
    return mainJNI.RoutingModel_arcIsMoreConstrainedThanArc(swigCPtr, this, from, to1, to2);
  }

  /**
   *  Print some debugging information about an assignment, including the feasible intervals of the CumulVar for dimension "dimension_to_print" at each step of the routes. If "dimension_to_print" is omitted, all dimensions will be printed.
   */
  public String debugOutputAssignment(Assignment solution_assignment, String dimension_to_print) {
    return mainJNI.RoutingModel_debugOutputAssignment(swigCPtr, this, Assignment.getCPtr(solution_assignment), solution_assignment, dimension_to_print);
  }

  /**
   *  Returns the underlying constraint solver. Can be used to add extra constraints and/or modify search algoithms.
   */
  public Solver solver() {
    long cPtr = mainJNI.RoutingModel_solver(swigCPtr, this);
    return (cPtr == 0) ? null : new Solver(cPtr, false);
  }

  /**
   *  Returns true if the search limit has been crossed.
   */
  public boolean checkLimit() {
    return mainJNI.RoutingModel_checkLimit(swigCPtr, this);
  }

  /**
   *  Sizes and indices Returns the number of nodes in the model.
   */
  public int nodes() {
    return mainJNI.RoutingModel_nodes(swigCPtr, this);
  }

  /**
   *  Returns the number of vehicle routes in the model.
   */
  public int vehicles() {
    return mainJNI.RoutingModel_vehicles(swigCPtr, this);
  }

  /**
   *  Returns the number of next variables in the model.
   */
  public long size() {
    return mainJNI.RoutingModel_size(swigCPtr, this);
  }

  /**
   *  Returns statistics on first solution search, number of decisions sent to filters, number of decisions rejected by filters.
   */
  public long getNumberOfDecisionsInFirstSolution(com.google.ortools.constraintsolver.RoutingSearchParameters search_parameters) {
    return mainJNI.RoutingModel_getNumberOfDecisionsInFirstSolution(swigCPtr, this, search_parameters.toByteArray());
  }

  public long getNumberOfRejectsInFirstSolution(com.google.ortools.constraintsolver.RoutingSearchParameters search_parameters) {
    return mainJNI.RoutingModel_getNumberOfRejectsInFirstSolution(swigCPtr, this, search_parameters.toByteArray());
  }

  /**
   *  Returns true if a vehicle/node matching problem is detected.
   */
  public boolean isMatchingModel() {
    return mainJNI.RoutingModel_isMatchingModel(swigCPtr, this);
  }

  /**
   *  The next few members are in the public section only for testing purposes. MakeGuidedSlackFinalizer creates a DecisionBuilder for the slacks of a dimension using a callback to choose which values to start with. The finalizer works only when all next variables in the model have been fixed. It has the following two characteristics: 1. It follows the routes defined by the nexts variables when choosing a    variable to make a decision on. 2. When it comes to choose a value for the slack of node i, the decision    builder first calls the callback with argument i, and supposingly the    returned value is x it creates decisions slack[i] = x, slack[i] = x +    1, slack[i] = x - 1, slack[i] = x + 2, etc.
   */
  public DecisionBuilder makeGuidedSlackFinalizer(RoutingDimension dimension, LongUnaryOperator initializer) {
    long cPtr = mainJNI.RoutingModel_makeGuidedSlackFinalizer(swigCPtr, this, RoutingDimension.getCPtr(dimension), dimension, initializer);
    return (cPtr == 0) ? null : new DecisionBuilder(cPtr, false);
  }

  /**
   *  MakeSelfDependentDimensionFinalizer is a finalizer for the slacks of a self-dependent dimension. It makes an extensive use of the caches of the state dependent transits. In detail, MakeSelfDependentDimensionFinalizer returns a composition of a local search decision builder with a greedy descent operator for the cumul of the start of each route and a guided slack finalizer. Provided there are no time windows and the maximum slacks are large enough, once the cumul of the start of route is fixed, the guided finalizer can find optimal values of the slacks for the rest of the route in time proportional to the length of the route. Therefore the composed finalizer generally works in time O(log(t)*n*m), where t is the latest possible departute time, n is the number of nodes in the network and m is the number of vehicles.
   */
  public DecisionBuilder makeSelfDependentDimensionFinalizer(RoutingDimension dimension) {
    long cPtr = mainJNI.RoutingModel_makeSelfDependentDimensionFinalizer(swigCPtr, this, RoutingDimension.getCPtr(dimension), dimension);
    return (cPtr == 0) ? null : new DecisionBuilder(cPtr, false);
  }

  public void addMatrixDimension(long[][] values, long capacity, boolean fix_start_cumul_to_zero, String name) {
    mainJNI.RoutingModel_addMatrixDimension(swigCPtr, this, values, capacity, fix_start_cumul_to_zero, name);
  }

  // Status 
  /**
   *  Status of the search.
   */

  /**
   *  Problem not solved yet (before calling RoutingModel::Solve()).
   */
  public final static int ROUTING_NOT_SOLVED = mainJNI.RoutingModel_ROUTING_NOT_SOLVED_get();
  /**
   *  Problem solved successfully after calling RoutingModel::Solve().
   */
  public final static int ROUTING_SUCCESS = mainJNI.RoutingModel_ROUTING_SUCCESS_get();
  /**
   *  No solution found to the problem after calling RoutingModel::Solve().
   */
  public final static int ROUTING_FAIL = mainJNI.RoutingModel_ROUTING_FAIL_get();
  /**
   *  Time limit reached before finding a solution with RoutingModel::Solve().
   */
  public final static int ROUTING_FAIL_TIMEOUT = mainJNI.RoutingModel_ROUTING_FAIL_TIMEOUT_get();
  /**
   *  Model, model parameters or flags are not valid.
   */
  public final static int ROUTING_INVALID = mainJNI.RoutingModel_ROUTING_INVALID_get();

  // PickupAndDeliveryPolicy 
  /**
   *  Types of precedence policy applied to pickup and delivery pairs.
   */

  /**
   *  Any precedence is accepted.
   */
  public final static int PICKUP_AND_DELIVERY_NO_ORDER = mainJNI.RoutingModel_PICKUP_AND_DELIVERY_NO_ORDER_get();
  /**
   *  Deliveries must be performed in reverse order of pickups.
   */
  public final static int PICKUP_AND_DELIVERY_LIFO = mainJNI.RoutingModel_PICKUP_AND_DELIVERY_LIFO_get();
  /**
   *  Deliveries must be performed in the same order as pickups.
   */
  public final static int PICKUP_AND_DELIVERY_FIFO = mainJNI.RoutingModel_PICKUP_AND_DELIVERY_FIFO_get();

}
